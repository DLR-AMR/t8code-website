<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>t8: t8_scheme Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">t8
   &#160;<span id="projectnumber">4.0.0-RC1.947-abbc</span>
   </div>
   <div id="projectbrief">t8code is a C library to manage a forest of adaptive                           space-trees of general element classes in parallel.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">t8_scheme Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class holds one or more element schemes.  
 <a href="classt8__scheme.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="t8__scheme_8hxx_source.html">t8_scheme.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aed7b30dc711a18f17e455b073c384823"><td class="memItemLeft" align="right" valign="top"><a id="aed7b30dc711a18f17e455b073c384823"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aed7b30dc711a18f17e455b073c384823">scheme_var</a> = std::variant&lt; <a class="el" href="classt8__default__scheme__vertex.html">t8_default_scheme_vertex</a>, <a class="el" href="classt8__default__scheme__line.html">t8_default_scheme_line</a>, <a class="el" href="classt8__default__scheme__quad.html">t8_default_scheme_quad</a>, <a class="el" href="classt8__default__scheme__tri.html">t8_default_scheme_tri</a>, <a class="el" href="classt8__default__scheme__hex.html">t8_default_scheme_hex</a>, <a class="el" href="classt8__default__scheme__tet.html">t8_default_scheme_tet</a>, <a class="el" href="classt8__default__scheme__prism.html">t8_default_scheme_prism</a>, <a class="el" href="classt8__default__scheme__pyramid.html">t8_default_scheme_pyramid</a>, <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9ac4ce741ff4e19d3e94aa1eb0c0e7abbd">T8_ECLASS_VERTEX</a> &gt;, <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9a9667a79817957d7f2446d73a9778b8b5">T8_ECLASS_LINE</a> &gt;, <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9a81e3f71a30727a94fc1c80da130297a9">T8_ECLASS_QUAD</a> &gt;, <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9a5780818d0b9120d3267db871196f866a">T8_ECLASS_HEX</a> &gt; &gt;</td></tr>
<tr class="memdesc:aed7b30dc711a18f17e455b073c384823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant to hold an eclass scheme. <br /></td></tr>
<tr class="separator:aed7b30dc711a18f17e455b073c384823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253d5c003fcee13597b774d3b02cbca3"><td class="memItemLeft" align="right" valign="top"><a id="a253d5c003fcee13597b774d3b02cbca3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a253d5c003fcee13597b774d3b02cbca3">scheme_container</a> = std::vector&lt; <a class="el" href="classt8__scheme.html#aed7b30dc711a18f17e455b073c384823">scheme_var</a> &gt;</td></tr>
<tr class="memdesc:a253d5c003fcee13597b774d3b02cbca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for holding eclass schemes. <br /></td></tr>
<tr class="separator:a253d5c003fcee13597b774d3b02cbca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a70cd77d30b141078ac231d5c4a9515b9"><td class="memItemLeft" align="right" valign="top"><a id="a70cd77d30b141078ac231d5c4a9515b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a70cd77d30b141078ac231d5c4a9515b9">ref</a> () const</td></tr>
<tr class="memdesc:a70cd77d30b141078ac231d5c4a9515b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference count of the scheme. <br /></td></tr>
<tr class="separator:a70cd77d30b141078ac231d5c4a9515b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3a78bc332b7868397b835c8317ac47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a4d3a78bc332b7868397b835c8317ac47">unref</a> () const</td></tr>
<tr class="memdesc:a4d3a78bc332b7868397b835c8317ac47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the reference count of the scheme.  <a href="classt8__scheme.html#a4d3a78bc332b7868397b835c8317ac47">More...</a><br /></td></tr>
<tr class="separator:a4d3a78bc332b7868397b835c8317ac47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d98eada4c87673a7c189a5b2a1cb7e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ad1d98eada4c87673a7c189a5b2a1cb7e">get_num_eclass_schemes</a> () const</td></tr>
<tr class="memdesc:ad1d98eada4c87673a7c189a5b2a1cb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of eclass schemes inside the scheme.  <a href="classt8__scheme.html#ad1d98eada4c87673a7c189a5b2a1cb7e">More...</a><br /></td></tr>
<tr class="separator:ad1d98eada4c87673a7c189a5b2a1cb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26cfd761c91248b59ce42902addacdd"><td class="memTemplParams" colspan="2">template&lt;class TEclassScheme &gt; </td></tr>
<tr class="memitem:ab26cfd761c91248b59ce42902addacdd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ab26cfd761c91248b59ce42902addacdd">check_eclass_scheme_type</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:ab26cfd761c91248b59ce42902addacdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the scheme is of a specific type.  <a href="classt8__scheme.html#ab26cfd761c91248b59ce42902addacdd">More...</a><br /></td></tr>
<tr class="separator:ab26cfd761c91248b59ce42902addacdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e212bb5f95d9e07e65b54c911d2c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a41e212bb5f95d9e07e65b54c911d2c71">get_eclass_scheme_eclass</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:a41e212bb5f95d9e07e65b54c911d2c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eclass an eclass scheme is valid for.  <a href="classt8__scheme.html#a41e212bb5f95d9e07e65b54c911d2c71">More...</a><br /></td></tr>
<tr class="separator:a41e212bb5f95d9e07e65b54c911d2c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6c4d7de5838d2a7bf7f99c29467533"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a2b6c4d7de5838d2a7bf7f99c29467533">get_element_size</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:a2b6c4d7de5838d2a7bf7f99c29467533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of any element of a given class.  <a href="classt8__scheme.html#a2b6c4d7de5838d2a7bf7f99c29467533">More...</a><br /></td></tr>
<tr class="separator:a2b6c4d7de5838d2a7bf7f99c29467533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5585e34278986190d562fa76c47d6470"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a5585e34278986190d562fa76c47d6470">refines_irregular</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:a5585e34278986190d562fa76c47d6470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if there is one element in the tree, that does not refine into 2^dim children.  <a href="classt8__scheme.html#a5585e34278986190d562fa76c47d6470">More...</a><br /></td></tr>
<tr class="separator:a5585e34278986190d562fa76c47d6470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ad9586fb7839910813418b6e5b22a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a42ad9586fb7839910813418b6e5b22a6">get_maxlevel</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:a42ad9586fb7839910813418b6e5b22a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowed level for any element of a given class.  <a href="classt8__scheme.html#a42ad9586fb7839910813418b6e5b22a6">More...</a><br /></td></tr>
<tr class="separator:a42ad9586fb7839910813418b6e5b22a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad446bc14b0be601c4aa9c628db6c0e3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ad446bc14b0be601c4aa9c628db6c0e3a">element_get_level</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ad446bc14b0be601c4aa9c628db6c0e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the level of a particular element.  <a href="classt8__scheme.html#ad446bc14b0be601c4aa9c628db6c0e3a">More...</a><br /></td></tr>
<tr class="separator:ad446bc14b0be601c4aa9c628db6c0e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab976202bc88eceaf814568eb81dc5e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ab976202bc88eceaf814568eb81dc5e7f">element_copy</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *source, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *dest) const</td></tr>
<tr class="memdesc:ab976202bc88eceaf814568eb81dc5e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all entries of <em>source</em> to <em>dest</em>.  <a href="classt8__scheme.html#ab976202bc88eceaf814568eb81dc5e7f">More...</a><br /></td></tr>
<tr class="separator:ab976202bc88eceaf814568eb81dc5e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6c2a91780403d2765bfc222098ba6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#acc6c2a91780403d2765bfc222098ba6c">element_compare</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2) const</td></tr>
<tr class="memdesc:acc6c2a91780403d2765bfc222098ba6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two elements.  <a href="classt8__scheme.html#acc6c2a91780403d2765bfc222098ba6c">More...</a><br /></td></tr>
<tr class="separator:acc6c2a91780403d2765bfc222098ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be24712101df44758b98fe8ae3eda27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a7be24712101df44758b98fe8ae3eda27">element_is_equal</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2) const</td></tr>
<tr class="memdesc:a7be24712101df44758b98fe8ae3eda27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two elements are equal.  <a href="classt8__scheme.html#a7be24712101df44758b98fe8ae3eda27">More...</a><br /></td></tr>
<tr class="separator:a7be24712101df44758b98fe8ae3eda27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340289b687773932881edbad77bfed09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a340289b687773932881edbad77bfed09">element_is_refinable</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a340289b687773932881edbad77bfed09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if an element is refinable.  <a href="classt8__scheme.html#a340289b687773932881edbad77bfed09">More...</a><br /></td></tr>
<tr class="separator:a340289b687773932881edbad77bfed09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a7d1ed8da911d24f44663e089536d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aa9a7d1ed8da911d24f44663e089536d3">element_get_parent</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *parent) const</td></tr>
<tr class="memdesc:aa9a7d1ed8da911d24f44663e089536d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the parent of a given element <em>elem</em> and store it in <em>parent</em>.  <a href="classt8__scheme.html#aa9a7d1ed8da911d24f44663e089536d3">More...</a><br /></td></tr>
<tr class="separator:aa9a7d1ed8da911d24f44663e089536d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b2d451321e88c4fd9b112f60358b65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a05b2d451321e88c4fd9b112f60358b65">element_get_num_siblings</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a05b2d451321e88c4fd9b112f60358b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of siblings of an element.  <a href="classt8__scheme.html#a05b2d451321e88c4fd9b112f60358b65">More...</a><br /></td></tr>
<tr class="separator:a05b2d451321e88c4fd9b112f60358b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c077dc91ca843128e893190cdfb138c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a2c077dc91ca843128e893190cdfb138c">element_get_sibling</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int sibid, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *sibling) const</td></tr>
<tr class="memdesc:a2c077dc91ca843128e893190cdfb138c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a specific sibling of a given element <em>elem</em> and store it in <em>sibling</em>.  <a href="classt8__scheme.html#a2c077dc91ca843128e893190cdfb138c">More...</a><br /></td></tr>
<tr class="separator:a2c077dc91ca843128e893190cdfb138c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100cf7a705b1ef6945bc64ce70b90d0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a100cf7a705b1ef6945bc64ce70b90d0d">element_get_num_corners</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a100cf7a705b1ef6945bc64ce70b90d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of corners of a given element.  <a href="classt8__scheme.html#a100cf7a705b1ef6945bc64ce70b90d0d">More...</a><br /></td></tr>
<tr class="separator:a100cf7a705b1ef6945bc64ce70b90d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada02b05362d184368acebac229b06df7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ada02b05362d184368acebac229b06df7">element_get_num_faces</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ada02b05362d184368acebac229b06df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of faces of a given element.  <a href="classt8__scheme.html#ada02b05362d184368acebac229b06df7">More...</a><br /></td></tr>
<tr class="separator:ada02b05362d184368acebac229b06df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18d46f1ed2db4ca608a98b0abf0218e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ac18d46f1ed2db4ca608a98b0abf0218e">element_get_max_num_faces</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ac18d46f1ed2db4ca608a98b0abf0218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum number of faces of a given element and all of its descendants.  <a href="classt8__scheme.html#ac18d46f1ed2db4ca608a98b0abf0218e">More...</a><br /></td></tr>
<tr class="separator:ac18d46f1ed2db4ca608a98b0abf0218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7faaaa013c4c3152bbc0de5cde198fb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a7faaaa013c4c3152bbc0de5cde198fb9">element_get_num_children</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a7faaaa013c4c3152bbc0de5cde198fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of an element when it is refined.  <a href="classt8__scheme.html#a7faaaa013c4c3152bbc0de5cde198fb9">More...</a><br /></td></tr>
<tr class="separator:a7faaaa013c4c3152bbc0de5cde198fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4cceb847d8bad3d0885ac94871ecb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a7a4cceb847d8bad3d0885ac94871ecb6">element_get_num_face_children</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face) const</td></tr>
<tr class="memdesc:a7a4cceb847d8bad3d0885ac94871ecb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of an element's face when the element is refined.  <a href="classt8__scheme.html#a7a4cceb847d8bad3d0885ac94871ecb6">More...</a><br /></td></tr>
<tr class="separator:a7a4cceb847d8bad3d0885ac94871ecb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d9253b553272dd2e966395eeb9f19f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a14d9253b553272dd2e966395eeb9f19f">element_get_face_corner</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face, const int corner) const</td></tr>
<tr class="memdesc:a14d9253b553272dd2e966395eeb9f19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corner number of an element's face corner.  <a href="classt8__scheme.html#a14d9253b553272dd2e966395eeb9f19f">More...</a><br /></td></tr>
<tr class="separator:a14d9253b553272dd2e966395eeb9f19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68809126cb1bab4401d306663db4f8c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a68809126cb1bab4401d306663db4f8c8">element_get_corner_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int corner, const int face) const</td></tr>
<tr class="memdesc:a68809126cb1bab4401d306663db4f8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the face numbers of the faces sharing an element's corner.  <a href="classt8__scheme.html#a68809126cb1bab4401d306663db4f8c8">More...</a><br /></td></tr>
<tr class="separator:a68809126cb1bab4401d306663db4f8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a56475d8e2539407c46860f9a555545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a0a56475d8e2539407c46860f9a555545">element_get_child</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int childid, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *child) const</td></tr>
<tr class="memdesc:a0a56475d8e2539407c46860f9a555545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the child element of a given number.  <a href="classt8__scheme.html#a0a56475d8e2539407c46860f9a555545">More...</a><br /></td></tr>
<tr class="separator:a0a56475d8e2539407c46860f9a555545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac904f5424e0c14015de5a02fe2c105f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ac904f5424e0c14015de5a02fe2c105f2">element_get_children</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *c[]) const</td></tr>
<tr class="memdesc:ac904f5424e0c14015de5a02fe2c105f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct all children of a given element.  <a href="classt8__scheme.html#ac904f5424e0c14015de5a02fe2c105f2">More...</a><br /></td></tr>
<tr class="separator:ac904f5424e0c14015de5a02fe2c105f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6021440102c23fee1bcf74e0946579c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a6021440102c23fee1bcf74e0946579c0">element_get_child_id</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a6021440102c23fee1bcf74e0946579c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the child id of an element.  <a href="classt8__scheme.html#a6021440102c23fee1bcf74e0946579c0">More...</a><br /></td></tr>
<tr class="separator:a6021440102c23fee1bcf74e0946579c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a55c1a68f3fbbe23ea10664f36c9e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a78a55c1a68f3fbbe23ea10664f36c9e0">element_get_ancestor_id</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int level) const</td></tr>
<tr class="memdesc:a78a55c1a68f3fbbe23ea10664f36c9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ancestor id of an element, that is the child id at a given level.  <a href="classt8__scheme.html#a78a55c1a68f3fbbe23ea10664f36c9e0">More...</a><br /></td></tr>
<tr class="separator:a78a55c1a68f3fbbe23ea10664f36c9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a0afde9fa6e9dda13e2bc33e403df2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a79a0afde9fa6e9dda13e2bc33e403df2">elements_are_family</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const *fam) const</td></tr>
<tr class="memdesc:a79a0afde9fa6e9dda13e2bc33e403df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a given set of elements is a family or not.  <a href="classt8__scheme.html#a79a0afde9fa6e9dda13e2bc33e403df2">More...</a><br /></td></tr>
<tr class="separator:a79a0afde9fa6e9dda13e2bc33e403df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db4f6029b2cacb3b3fd2ad4d12a4b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a5db4f6029b2cacb3b3fd2ad4d12a4b8b">element_get_nca</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const nca) const</td></tr>
<tr class="memdesc:a5db4f6029b2cacb3b3fd2ad4d12a4b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nearest common ancestor of two elements.  <a href="classt8__scheme.html#a5db4f6029b2cacb3b3fd2ad4d12a4b8b">More...</a><br /></td></tr>
<tr class="separator:a5db4f6029b2cacb3b3fd2ad4d12a4b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d90099c58ea3128e262ad8279e9aa4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a0d90099c58ea3128e262ad8279e9aa4a">element_get_face_shape</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face) const</td></tr>
<tr class="memdesc:a0d90099c58ea3128e262ad8279e9aa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shape of the face of an element.  <a href="classt8__scheme.html#a0d90099c58ea3128e262ad8279e9aa4a">More...</a><br /></td></tr>
<tr class="separator:a0d90099c58ea3128e262ad8279e9aa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0296f8812d7f241e16737261e44f7355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a0296f8812d7f241e16737261e44f7355">element_get_children_at_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *children[], int num_children, int *child_indices) const</td></tr>
<tr class="memdesc:a0296f8812d7f241e16737261e44f7355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of the element, compute all children of the element that touch the face.  <a href="classt8__scheme.html#a0296f8812d7f241e16737261e44f7355">More...</a><br /></td></tr>
<tr class="separator:a0296f8812d7f241e16737261e44f7355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508efc7787bb9ffe830b2f1bef60eec3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a508efc7787bb9ffe830b2f1bef60eec3">element_face_get_child_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, const int face_child) const</td></tr>
<tr class="memdesc:a508efc7787bb9ffe830b2f1bef60eec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face.  <a href="classt8__scheme.html#a508efc7787bb9ffe830b2f1bef60eec3">More...</a><br /></td></tr>
<tr class="separator:a508efc7787bb9ffe830b2f1bef60eec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ff5bcf3a00aea8d313397183e0707a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a37ff5bcf3a00aea8d313397183e0707a">element_face_get_parent_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face) const</td></tr>
<tr class="memdesc:a37ff5bcf3a00aea8d313397183e0707a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element return the face number of the parent of the element that matches the element's face.  <a href="classt8__scheme.html#a37ff5bcf3a00aea8d313397183e0707a">More...</a><br /></td></tr>
<tr class="separator:a37ff5bcf3a00aea8d313397183e0707a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e6088c02b873127925b4469c9b9660"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a38e6088c02b873127925b4469c9b9660">element_get_tree_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face) const</td></tr>
<tr class="memdesc:a38e6088c02b873127925b4469c9b9660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of this element.  <a href="classt8__scheme.html#a38e6088c02b873127925b4469c9b9660">More...</a><br /></td></tr>
<tr class="separator:a38e6088c02b873127925b4469c9b9660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54cbd6c146c7b93ac4a8cf65efb7079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aa54cbd6c146c7b93ac4a8cf65efb7079">element_transform_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, const int orientation, const int sign, const int is_smaller_face) const</td></tr>
<tr class="memdesc:aa54cbd6c146c7b93ac4a8cf65efb7079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppose we have two trees that share a common face f.  <a href="classt8__scheme.html#aa54cbd6c146c7b93ac4a8cf65efb7079">More...</a><br /></td></tr>
<tr class="separator:aa54cbd6c146c7b93ac4a8cf65efb7079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52773b471db244fade72eb7ef37cef56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a52773b471db244fade72eb7ef37cef56">element_extrude_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int root_face) const</td></tr>
<tr class="memdesc:a52773b471db244fade72eb7ef37cef56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face.  <a href="classt8__scheme.html#a52773b471db244fade72eb7ef37cef56">More...</a><br /></td></tr>
<tr class="separator:a52773b471db244fade72eb7ef37cef56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab86fe21e3053cdf57c86963c5ad6e33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aab86fe21e3053cdf57c86963c5ad6e33">element_get_boundary_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *boundary) const</td></tr>
<tr class="memdesc:aab86fe21e3053cdf57c86963c5ad6e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the boundary element at a specific face.  <a href="classt8__scheme.html#aab86fe21e3053cdf57c86963c5ad6e33">More...</a><br /></td></tr>
<tr class="separator:aab86fe21e3053cdf57c86963c5ad6e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9d1aeca1a202af994659dd1cc300ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a5f9d1aeca1a202af994659dd1cc300ad">element_get_first_descendant_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *first_desc, const int level) const</td></tr>
<tr class="memdesc:a5f9d1aeca1a202af994659dd1cc300ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the first descendant of an element at a given level that touches a given face.  <a href="classt8__scheme.html#a5f9d1aeca1a202af994659dd1cc300ad">More...</a><br /></td></tr>
<tr class="separator:a5f9d1aeca1a202af994659dd1cc300ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6112f73ed4285e9131ebeeed11a57780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a6112f73ed4285e9131ebeeed11a57780">element_get_last_descendant_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *last_desc, const int level) const</td></tr>
<tr class="memdesc:a6112f73ed4285e9131ebeeed11a57780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the last descendant of an element at a given level that touches a given face.  <a href="classt8__scheme.html#a6112f73ed4285e9131ebeeed11a57780">More...</a><br /></td></tr>
<tr class="separator:a6112f73ed4285e9131ebeeed11a57780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ca0ed62f4cda7ca215c7aa283d1d62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a69ca0ed62f4cda7ca215c7aa283d1d62">element_is_root_boundary</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face) const</td></tr>
<tr class="memdesc:a69ca0ed62f4cda7ca215c7aa283d1d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether a given element shares a given face with its root tree.  <a href="classt8__scheme.html#a69ca0ed62f4cda7ca215c7aa283d1d62">More...</a><br /></td></tr>
<tr class="separator:a69ca0ed62f4cda7ca215c7aa283d1d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6dc7523cace0b19ead78e63840afaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a6b6dc7523cace0b19ead78e63840afaf">element_get_face_neighbor_inside</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *neigh, const int face, int *neigh_face) const</td></tr>
<tr class="memdesc:a6b6dc7523cace0b19ead78e63840afaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the face neighbor of a given element if this face neighbor is inside the root tree.  <a href="classt8__scheme.html#a6b6dc7523cace0b19ead78e63840afaf">More...</a><br /></td></tr>
<tr class="separator:a6b6dc7523cace0b19ead78e63840afaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada42fcf420f367798f4ac1a0edc1e292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ada42fcf420f367798f4ac1a0edc1e292">element_get_shape</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ada42fcf420f367798f4ac1a0edc1e292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shape of an allocated element according its type.  <a href="classt8__scheme.html#ada42fcf420f367798f4ac1a0edc1e292">More...</a><br /></td></tr>
<tr class="separator:ada42fcf420f367798f4ac1a0edc1e292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af061b230670a10f9e7f567e9349c4331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#af061b230670a10f9e7f567e9349c4331">element_set_linear_id</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int level, const <a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> id) const</td></tr>
<tr class="memdesc:af061b230670a10f9e7f567e9349c4331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the entries of an allocated element according to a given linear id in a uniform refinement.  <a href="classt8__scheme.html#af061b230670a10f9e7f567e9349c4331">More...</a><br /></td></tr>
<tr class="separator:af061b230670a10f9e7f567e9349c4331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19af30ae13cdadbd77f791d8531e5821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a19af30ae13cdadbd77f791d8531e5821">element_get_linear_id</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int level) const</td></tr>
<tr class="memdesc:a19af30ae13cdadbd77f791d8531e5821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linear id of a given element in a hypothetical uniform refinement of a given level.  <a href="classt8__scheme.html#a19af30ae13cdadbd77f791d8531e5821">More...</a><br /></td></tr>
<tr class="separator:a19af30ae13cdadbd77f791d8531e5821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdebfd511538f49a26c76e3cb5be52a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#afdebfd511538f49a26c76e3cb5be52a9">element_get_first_descendant</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, const int level) const</td></tr>
<tr class="memdesc:afdebfd511538f49a26c76e3cb5be52a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first descendant of a given element.  <a href="classt8__scheme.html#afdebfd511538f49a26c76e3cb5be52a9">More...</a><br /></td></tr>
<tr class="separator:afdebfd511538f49a26c76e3cb5be52a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca801518570b74db90c24759d7f96db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aca801518570b74db90c24759d7f96db3">element_get_last_descendant</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, const int level) const</td></tr>
<tr class="memdesc:aca801518570b74db90c24759d7f96db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the last descendant of a given element.  <a href="classt8__scheme.html#aca801518570b74db90c24759d7f96db3">More...</a><br /></td></tr>
<tr class="separator:aca801518570b74db90c24759d7f96db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9a4e136ad094f7eb6243cc62c13af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a98c9a4e136ad094f7eb6243cc62c13af">element_construct_successor</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *t, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *s) const</td></tr>
<tr class="memdesc:a98c9a4e136ad094f7eb6243cc62c13af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the successor in a uniform refinement of a given element.  <a href="classt8__scheme.html#a98c9a4e136ad094f7eb6243cc62c13af">More...</a><br /></td></tr>
<tr class="separator:a98c9a4e136ad094f7eb6243cc62c13af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e049a4ab221565ed07f01ef57c8f6cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a1e049a4ab221565ed07f01ef57c8f6cd">element_get_vertex_reference_coords</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *t, const int vertex, double coords[]) const</td></tr>
<tr class="memdesc:a1e049a4ab221565ed07f01ef57c8f6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension).  <a href="classt8__scheme.html#a1e049a4ab221565ed07f01ef57c8f6cd">More...</a><br /></td></tr>
<tr class="separator:a1e049a4ab221565ed07f01ef57c8f6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6bc45f3e1e5fad3423bc5eae278f94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a1f6bc45f3e1e5fad3423bc5eae278f94">element_get_reference_coords</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const double *ref_coords, const size_t num_coords, double *out_coords) const</td></tr>
<tr class="memdesc:a1f6bc45f3e1e5fad3423bc5eae278f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points in the reference space of an element to points in the reference space of the tree.  <a href="classt8__scheme.html#a1f6bc45f3e1e5fad3423bc5eae278f94">More...</a><br /></td></tr>
<tr class="separator:a1f6bc45f3e1e5fad3423bc5eae278f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be187f0be562e3e2d899f05c9709826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a9be187f0be562e3e2d899f05c9709826">element_count_leaves</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *t, const int level) const</td></tr>
<tr class="memdesc:a9be187f0be562e3e2d899f05c9709826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many leaf descendants of a given uniform level an element would produce.  <a href="classt8__scheme.html#a9be187f0be562e3e2d899f05c9709826">More...</a><br /></td></tr>
<tr class="separator:a9be187f0be562e3e2d899f05c9709826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db97e764b0195c22006227874d24afd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a5db97e764b0195c22006227874d24afd">count_leaves_from_root</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int level) const</td></tr>
<tr class="memdesc:a5db97e764b0195c22006227874d24afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many leaf descendants of a given uniform level the root element will produce.  <a href="classt8__scheme.html#a5db97e764b0195c22006227874d24afd">More...</a><br /></td></tr>
<tr class="separator:a5db97e764b0195c22006227874d24afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39d236fae4db6a2e6c1d234f17e1628"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ac39d236fae4db6a2e6c1d234f17e1628">element_is_valid</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ac39d236fae4db6a2e6c1d234f17e1628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a given element can be considered as 'valid' and it is safe to perform any of the above algorithms on it.  <a href="classt8__scheme.html#ac39d236fae4db6a2e6c1d234f17e1628">More...</a><br /></td></tr>
<tr class="separator:ac39d236fae4db6a2e6c1d234f17e1628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd50d5ce709004a1760cd4a4aeb258f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a5fd50d5ce709004a1760cd4a4aeb258f">element_debug_print</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a5fd50d5ce709004a1760cd4a4aeb258f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a given element.  <a href="classt8__scheme.html#a5fd50d5ce709004a1760cd4a4aeb258f">More...</a><br /></td></tr>
<tr class="separator:a5fd50d5ce709004a1760cd4a4aeb258f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c6609d8b60530303d8a8c85b56fb27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ab4c6609d8b60530303d8a8c85b56fb27">element_to_string</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, char *debug_string, const int string_size) const</td></tr>
<tr class="memdesc:ab4c6609d8b60530303d8a8c85b56fb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a string with readable information about the element.  <a href="classt8__scheme.html#ab4c6609d8b60530303d8a8c85b56fb27">More...</a><br /></td></tr>
<tr class="separator:ab4c6609d8b60530303d8a8c85b56fb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac840fcf8915fffd21f2d75dca2382ae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ac840fcf8915fffd21f2d75dca2382ae5">element_new</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elem) const</td></tr>
<tr class="memdesc:ac840fcf8915fffd21f2d75dca2382ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for <em>length</em> many elements of a given class and initialize them, and put pointers to the elements in the provided array.  <a href="classt8__scheme.html#ac840fcf8915fffd21f2d75dca2382ae5">More...</a><br /></td></tr>
<tr class="separator:ac840fcf8915fffd21f2d75dca2382ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dee93ff3ee83bf71d73387c24a50d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ac2dee93ff3ee83bf71d73387c24a50d0">element_init</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ac2dee93ff3ee83bf71d73387c24a50d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an array of allocated elements.  <a href="classt8__scheme.html#ac2dee93ff3ee83bf71d73387c24a50d0">More...</a><br /></td></tr>
<tr class="separator:ac2dee93ff3ee83bf71d73387c24a50d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad252dd70cdbe7454ab62b3fd79cdbbc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ad252dd70cdbe7454ab62b3fd79cdbbc7">element_deinit</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ad252dd70cdbe7454ab62b3fd79cdbbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize an array of allocated elements.  <a href="classt8__scheme.html#ad252dd70cdbe7454ab62b3fd79cdbbc7">More...</a><br /></td></tr>
<tr class="separator:ad252dd70cdbe7454ab62b3fd79cdbbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbacc81b501a6b2f842d38f8fe767df0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#abbacc81b501a6b2f842d38f8fe767df0">element_destroy</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elem) const</td></tr>
<tr class="memdesc:abbacc81b501a6b2f842d38f8fe767df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate an array of elements.  <a href="classt8__scheme.html#abbacc81b501a6b2f842d38f8fe767df0">More...</a><br /></td></tr>
<tr class="separator:abbacc81b501a6b2f842d38f8fe767df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae950879e9d7dc59518d0f5908bfbd78e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ae950879e9d7dc59518d0f5908bfbd78e">set_to_root</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ae950879e9d7dc59518d0f5908bfbd78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create the root element  <a href="classt8__scheme.html#ae950879e9d7dc59518d0f5908bfbd78e">More...</a><br /></td></tr>
<tr class="separator:ae950879e9d7dc59518d0f5908bfbd78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e3c7a9f56253e11e36156e3cd52a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a42e3c7a9f56253e11e36156e3cd52a8f">element_MPI_Pack</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **const elements, const unsigned int count, void *send_buffer, int buffer_size, int *position, sc_MPI_Comm comm) const</td></tr>
<tr class="memdesc:a42e3c7a9f56253e11e36156e3cd52a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack multiple elements into contiguous memory, so they can be sent via MPI.  <a href="classt8__scheme.html#a42e3c7a9f56253e11e36156e3cd52a8f">More...</a><br /></td></tr>
<tr class="separator:a42e3c7a9f56253e11e36156e3cd52a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66cf5e55cb110aafd7249689850936e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aa66cf5e55cb110aafd7249689850936e">element_MPI_Pack_size</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const unsigned int count, sc_MPI_Comm comm, int *pack_size) const</td></tr>
<tr class="memdesc:aa66cf5e55cb110aafd7249689850936e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine an upper bound for the size of the packed message of <em>count</em> elements.  <a href="classt8__scheme.html#aa66cf5e55cb110aafd7249689850936e">More...</a><br /></td></tr>
<tr class="separator:aa66cf5e55cb110aafd7249689850936e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6038aefd4b83edc4325c590cc5ad3e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a6038aefd4b83edc4325c590cc5ad3e74">element_MPI_Unpack</a> (<a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, void *recvbuf, const int buffer_size, int *position, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elements, const unsigned int count, sc_MPI_Comm comm) const</td></tr>
<tr class="memdesc:a6038aefd4b83edc4325c590cc5ad3e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack multiple elements from contiguous memory that was received via MPI.  <a href="classt8__scheme.html#a6038aefd4b83edc4325c590cc5ad3e74">More...</a><br /></td></tr>
<tr class="separator:a6038aefd4b83edc4325c590cc5ad3e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afea6512ca68ced2086be8bb24e948a97"><td class="memItemLeft" align="right" valign="top"><a id="afea6512ca68ced2086be8bb24e948a97"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>t8_scheme_builder</b></td></tr>
<tr class="separator:afea6512ca68ced2086be8bb24e948a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class holds one or more element schemes. </p>
<p>It also relays the function calls to the specific schemes. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab26cfd761c91248b59ce42902addacdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26cfd761c91248b59ce42902addacdd">&#9670;&nbsp;</a></span>check_eclass_scheme_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEclassScheme &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::check_eclass_scheme_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the scheme is of a specific type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEclass_Scheme</td><td>The type of the scheme to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the scheme is of type <em>TEclassScheme</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="a5db97e764b0195c22006227874d24afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db97e764b0195c22006227874d24afd">&#9670;&nbsp;</a></span>count_leaves_from_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a> t8_scheme::count_leaves_from_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count how many leaf descendants of a given uniform level the root element will produce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <a class="el" href="t8__scheme_8h.html#a8e292133f473afd79d35e070bc258abd">t8_element_count_leaves</a> if the input element is the root (level 0) element.</dd></dl>
<p>This is a convenience function, and can be implemented via <a class="el" href="t8__scheme_8h.html#a8e292133f473afd79d35e070bc258abd">t8_element_count_leaves</a>. </p>

</div>
</div>
<a id="acc6c2a91780403d2765bfc222098ba6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6c2a91780403d2765bfc222098ba6c">&#9670;&nbsp;</a></span>element_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative if elem1 &lt; elem2, zero if elem1 equals elem2 and positive if elem1 &gt; elem2. If elem2 is a copy of elem1 then the elements are equal. </dd></dl>

</div>
</div>
<a id="a98c9a4e136ad094f7eb6243cc62c13af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c9a4e136ad094f7eb6243cc62c13af">&#9670;&nbsp;</a></span>element_construct_successor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_construct_successor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the successor in a uniform refinement of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The element whose successor should be constructed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>The element whose entries will be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab976202bc88eceaf814568eb81dc5e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab976202bc88eceaf814568eb81dc5e7f">&#9670;&nbsp;</a></span>element_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all entries of <em>source</em> to <em>dest</em>. </p>
<p><em>dest</em> must be an existing element. No memory is allocated by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The element whose entries will be copied to <em>dest</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>This element's entries will be overwritten with the entries of <em>source</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>source</em> and <em>dest</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="a9be187f0be562e3e2d899f05c9709826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be187f0be562e3e2d899f05c9709826">&#9670;&nbsp;</a></span>element_count_leaves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a> t8_scheme::element_count_leaves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count how many leaf descendants of a given uniform level an element would produce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The element to be checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Suppose <em>t</em> is uniformly refined up to level <em>level</em>. The return value is the resulting number of elements (of the given level). If <em>level</em> &lt; element_get_level(t), the return value should be 0.</dd></dl>
<p>Example: If <em>t</em> is a line element that refines into 2 line elements on each level, then the return value is max(0, 2^{<em>level</em> - level(<em>t</em>)}). Thus, if <em>t's</em> level is 0, and <em>level</em> = 3, the return value is 2^3 = 8. </p>

</div>
</div>
<a id="a5fd50d5ce709004a1760cd4a4aeb258f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd50d5ce709004a1760cd4a4aeb258f">&#9670;&nbsp;</a></span>element_debug_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_debug_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a given element. </p>
<p>For a example for a triangle print the coordinates and the level of the triangle. This function is only available in the debugging configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad252dd70cdbe7454ab62b3fd79cdbbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad252dd70cdbe7454ab62b3fd79cdbbc7">&#9670;&nbsp;</a></span>element_deinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_deinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deinitialize an array of allocated elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be deinitialized. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elems</td><td>On input an array of <em>length</em> many allocated and initialized elements, on output an array of <em>length</em> many allocated, but not initialized elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Call this function if you called t8_element_init on the element pointers. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>t8_element_init </dd></dl>

</div>
</div>
<a id="abbacc81b501a6b2f842d38f8fe767df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbacc81b501a6b2f842d38f8fe767df0">&#9670;&nbsp;</a></span>element_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_destroy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate an array of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>On input an array of <em>length</em> many allocated element pointers. On output all these pointers will be freed. <em>elem</em> itself will not be freed by this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__scheme_8h.html#aebd772f965b1fa5ff5ae10fe8c0950d9" title="Allocate memory for an array of elements of a given class and initialize them.">t8_element_new</a> </dd></dl>

</div>
</div>
<a id="a52773b471db244fade72eb7ef37cef56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52773b471db244fade72eb7ef37cef56">&#9670;&nbsp;</a></span>element_extrude_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_extrude_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>root_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>An allocated element. The entries will be filled with the data of the element that has <em>face</em> as a face and lies within the root tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_face</td><td>The index of the face of the root tree in which <em>face</em> lies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of <em>elem</em> that coincides with <em>face</em>. </dd></dl>

</div>
</div>
<a id="a508efc7787bb9ffe830b2f1bef60eec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508efc7787bb9ffe830b2f1bef60eec3">&#9670;&nbsp;</a></span>element_face_get_child_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_face_get_child_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face_child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face. </p>
<pre class="fragment"> x ---- x   x      x           x ---- x
 |      |   |      |           |   |  | &lt;-- f
 |      |   |      x           |   x--x
 |      |   |                  |      |
 x ---- x   x                  x ---- x
  elem    face  face_child    Returns the face number f
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_child</td><td>A number 0 &lt;= <em>face_child</em> &lt; num_face_children, specifying a child of <em>elem</em> that shares a face with <em>face</em>. These children are counted in linear order. This coincides with the order of children from a call to t8_element_children_at_face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of a child of <em>elem</em> that coincides with <em>face_child</em>. </dd></dl>

</div>
</div>
<a id="a37ff5bcf3a00aea8d313397183e0707a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ff5bcf3a00aea8d313397183e0707a">&#9670;&nbsp;</a></span>element_face_get_parent_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_face_get_parent_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a face of an element return the face number of the parent of the element that matches the element's face. </p>
<p>Or return -1 if no face of the parent matches the face. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>face</em> of <em>elem</em> is also a face of <em>elem's</em> parent, the face number of this face. Otherwise -1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For the root element this function always returns <em>face</em>. </dd></dl>

</div>
</div>
<a id="a78a55c1a68f3fbbe23ea10664f36c9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a55c1a68f3fbbe23ea10664f36c9e0">&#9670;&nbsp;</a></span>element_get_ancestor_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_ancestor_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the ancestor id of an element, that is the child id at a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. Must satisfy <em>level</em> &lt;= elem.level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child_id of <em>elem</em> in regard to its <em>level</em> ancestor. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ancestor id at elem.level is the same as the child id. </dd></dl>

</div>
</div>
<a id="aab86fe21e3053cdf57c86963c5ad6e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab86fe21e3053cdf57c86963c5ad6e33">&#9670;&nbsp;</a></span>element_get_boundary_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_boundary_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the boundary element at a specific face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of the face of which to construct the boundary element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">boundary</td><td>An allocated element of dimension of <em>element</em> minus 1. The entries will be filled with the entries of the face of <em>element</em>. If <em>elem</em> is of class T8_ECLASS_VERTEX, then <em>boundary</em> must be NULL and will not be modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a56475d8e2539407c46860f9a555545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a56475d8e2539407c46860f9a555545">&#9670;&nbsp;</a></span>element_get_child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>childid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the child element of a given number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childid</td><td>The number of the child to construct. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child</td><td>The storage for this element must exist. On output, a valid element. It is valid to call this function with elem = child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6021440102c23fee1bcf74e0946579c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6021440102c23fee1bcf74e0946579c0">&#9670;&nbsp;</a></span>element_get_child_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_child_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the child id of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child id of elem. </dd></dl>

</div>
</div>
<a id="ac904f5424e0c14015de5a02fe2c105f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac904f5424e0c14015de5a02fe2c105f2">&#9670;&nbsp;</a></span>element_get_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct all children of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the output array <em>c</em> must match the number of children. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The storage for these <em>length</em> elements must exist. On output, all children are valid. It is valid to call this function with elem = c[0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>t8_element_num_children </dd></dl>

</div>
</div>
<a id="a0296f8812d7f241e16737261e44f7355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0296f8812d7f241e16737261e44f7355">&#9670;&nbsp;</a></span>element_get_children_at_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_children_at_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>child_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an element and a face of the element, compute all children of the element that touch the face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">children</td><td>Allocated elements, in which the children of <em>elem</em> that share a face with <em>face</em> are stored. They will be stored in order of their linear id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_children</td><td>The number of elements in <em>children</em>. Must match the number of children that touch <em>face</em>. t8_element_num_face_children </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child_indices</td><td>If not NULL, an array of num_children integers must be given, on output its i-th entry is the child_id of the i-th face_child. It is valid to call this function with elem = children[0]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68809126cb1bab4401d306663db4f8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68809126cb1bab4401d306663db4f8c8">&#9670;&nbsp;</a></span>element_get_corner_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_corner_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the face numbers of the faces sharing an element's corner. </p>
<p>Example quad: 2 x &mdash; x 3 | | | | face 1 0 x &mdash; x 1 face 2 Thus for corner = 1 the output is: face=0 : 2, face=1: 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>corner</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the <em>face-th</em> face at <em>corner</em>. </dd></dl>

</div>
</div>
<a id="a14d9253b553272dd2e966395eeb9f19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d9253b553272dd2e966395eeb9f19f">&#9670;&nbsp;</a></span>element_get_face_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_face_corner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the corner number of an element's face corner. </p>
<p>Example quad: 2 x &mdash; x 3 | | | | face 1 0 x &mdash; x 1 Thus for face = 1 the output is: corner=0 : 1, corner=1: 3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face 0 &lt;= <em>corner</em> &lt; num_face_corners. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corner number of the <em>corner-th</em> vertex of <em>face</em>. </dd></dl>

</div>
</div>
<a id="a6b6dc7523cace0b19ead78e63840afaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6dc7523cace0b19ead78e63840afaf">&#9670;&nbsp;</a></span>element_get_face_neighbor_inside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_face_neighbor_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>neigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neigh_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the face neighbor of a given element if this face neighbor is inside the root tree. </p>
<p>Return 0 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">neigh</td><td>If the face neighbor of <em>elem</em> along <em>face</em> is inside the root tree, this element's data is filled with the data of the face neighbor. Otherwise the data can be modified arbitrarily. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The number of the face along which the neighbor should be constructed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neigh_face</td><td>The number of <em>face</em> as viewed from <em>neigh</em>. An arbitrary value, if the neighbor is not inside the root tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>neigh</em> is inside the root tree. False if not. In this case <em>neigh's</em> data can be arbitrary on output. </dd></dl>

</div>
</div>
<a id="a0d90099c58ea3128e262ad8279e9aa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d90099c58ea3128e262ad8279e9aa4a">&#9670;&nbsp;</a></span>element_get_face_shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a> t8_scheme::element_get_face_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the shape of the face of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element shape of the face. I.e. T8_ECLASS_LINE for quads, T8_ECLASS_TRIANGLE for tets and depending on the face number either T8_ECLASS_QUAD or T8_ECLASS_TRIANGLE for prisms. </dd></dl>

</div>
</div>
<a id="afdebfd511538f49a26c76e3cb5be52a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdebfd511538f49a26c76e3cb5be52a9">&#9670;&nbsp;</a></span>element_get_first_descendant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_first_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the first descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The first element in a uniform refinement of <em>elem</em> of the given level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the descendant is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f9d1aeca1a202af994659dd1cc300ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9d1aeca1a202af994659dd1cc300ad">&#9670;&nbsp;</a></span>element_get_first_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_first_descendant_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>first_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the first descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">first_desc</td><td>An allocated element. This element's data will be filled with the data of the first descendant of <em>elem</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the first descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca801518570b74db90c24759d7f96db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca801518570b74db90c24759d7f96db3">&#9670;&nbsp;</a></span>element_get_last_descendant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_last_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the last descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The last element in a uniform refinement of <em>elem</em> of the given level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the descendant is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6112f73ed4285e9131ebeeed11a57780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6112f73ed4285e9131ebeeed11a57780">&#9670;&nbsp;</a></span>element_get_last_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_last_descendant_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>last_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the last descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">last_desc</td><td>An allocated element. This element's data will be filled with the data of the last descendant of <em>elem</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the last descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad446bc14b0be601c4aa9c628db6c0e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad446bc14b0be601c4aa9c628db6c0e3a">&#9670;&nbsp;</a></span>element_get_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the level of a particular element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose level should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level of <em>elem</em>. </dd></dl>

</div>
</div>
<a id="a19af30ae13cdadbd77f791d8531e5821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19af30ae13cdadbd77f791d8531e5821">&#9670;&nbsp;</a></span>element_get_linear_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> t8_scheme::element_get_linear_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the linear id of a given element in a hypothetical uniform refinement of a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose id we compute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear id of the element. </dd></dl>

</div>
</div>
<a id="ac18d46f1ed2db4ca608a98b0abf0218e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18d46f1ed2db4ca608a98b0abf0218e">&#9670;&nbsp;</a></span>element_get_max_num_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_max_num_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the maximum number of faces of a given element and all of its descendants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of faces of <em>elem</em> and its descendants. </dd></dl>

</div>
</div>
<a id="a5db4f6029b2cacb3b3fd2ad4d12a4b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db4f6029b2cacb3b3fd2ad4d12a4b8b">&#9670;&nbsp;</a></span>element_get_nca()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_nca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const&#160;</td>
          <td class="paramname"><em>nca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nearest common ancestor of two elements. </p>
<p>That is, the element with highest level that still has both given elements as descendants. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first of the two input elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second of the two input elements. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nca</td><td>The storage for this element must exist and match the element class of the child. On output the unique nearest common ancestor of <em>elem1</em> and <em>elem2</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7faaaa013c4c3152bbc0de5cde198fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7faaaa013c4c3152bbc0de5cde198fb9">&#9670;&nbsp;</a></span>element_get_num_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of children of an element when it is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose number of children is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>elem</em> if it is to be refined. </dd></dl>

</div>
</div>
<a id="a100cf7a705b1ef6945bc64ce70b90d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100cf7a705b1ef6945bc64ce70b90d0d">&#9670;&nbsp;</a></span>element_get_num_corners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_corners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of corners of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of corners of <em>elem</em>. </dd></dl>

</div>
</div>
<a id="a7a4cceb847d8bad3d0885ac94871ecb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4cceb847d8bad3d0885ac94871ecb6">&#9670;&nbsp;</a></span>element_get_num_face_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_face_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of children of an element's face when the element is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose face is considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>face</em> if <em>elem</em> is to be refined. </dd></dl>

</div>
</div>
<a id="ada02b05362d184368acebac229b06df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada02b05362d184368acebac229b06df7">&#9670;&nbsp;</a></span>element_get_num_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of faces of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of faces of <em>elem</em>. </dd></dl>

</div>
</div>
<a id="a05b2d451321e88c4fd9b112f60358b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b2d451321e88c4fd9b112f60358b65">&#9670;&nbsp;</a></span>element_get_num_siblings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_siblings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of siblings of an element. </p>
<p>That is the number of Children of its parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of siblings of <em>element</em>. Note that this number is &gt;= 1, since we count the element itself as a sibling. </dd></dl>

</div>
</div>
<a id="aa9a7d1ed8da911d24f44663e089536d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a7d1ed8da911d24f44663e089536d3">&#9670;&nbsp;</a></span>element_get_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the parent of a given element <em>elem</em> and store it in <em>parent</em>. </p>
<p><em>parent</em> needs to be an existing element. No memory is allocated by this function. <em>elem</em> and <em>parent</em> can point to the same element, then the entries of <em>elem</em> are overwritten by the ones of its parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose parent will be computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parent</td><td>This element's entries will be overwritten by those of <em>elem's</em> parent. The storage for this element must exist and match the element class of the parent. For a pyramid, for example, it may be either a tetrahedron or a pyramid depending on <em>elem's</em> childid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f6bc45f3e1e5fad3423bc5eae278f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6bc45f3e1e5fad3423bc5eae278f94">&#9670;&nbsp;</a></span>element_get_reference_coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_reference_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>ref_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert points in the reference space of an element to points in the reference space of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coords_input</td><td>The coordinates \( [0,1]^\mathrm{dim} \) of the point in the reference space of the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_coords</td><td>Number of \( dim\)-sized coordinates to evaluate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_coords</td><td>The coordinates of the points in the reference space of the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada42fcf420f367798f4ac1a0edc1e292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada42fcf420f367798f4ac1a0edc1e292">&#9670;&nbsp;</a></span>element_get_shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a> t8_scheme::element_get_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the shape of an allocated element according its type. </p>
<p>For example, a child of an element can be an element of a different shape and has to be handled differently - according to its shape. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shape of the element as an eclass </dd></dl>

</div>
</div>
<a id="a2c077dc91ca843128e893190cdfb138c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c077dc91ca843128e893190cdfb138c">&#9670;&nbsp;</a></span>element_get_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_sibling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sibid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>sibling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a specific sibling of a given element <em>elem</em> and store it in <em>sibling</em>. </p>
<p><em>sibling</em> needs to be an existing element. No memory is allocated by this function. <em>elem</em> and <em>sibling</em> can point to the same element, then the entries of <em>elem</em> are overwritten by the ones of its sibid-th sibling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose sibling will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sibid</td><td>The id of the sibling computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sibling</td><td>This element's entries will be overwritten by those of <em>elem's</em> sibid-th sibling. The storage for this element must exist and match the element class of the sibling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38e6088c02b873127925b4469c9b9660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e6088c02b873127925b4469c9b9660">&#9670;&nbsp;</a></span>element_get_tree_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_tree_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an element and a face of this element. </p>
<p>If the face lies on the tree boundary, return the face number of the tree face. If not the return value is arbitrary. You can call <a class="el" href="t8__scheme_8h.html#af501e021c09d3aaff227d8b094dd71f1">t8_element_is_root_boundary</a> to query whether the face is at the tree boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of a face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the tree face that <em>face</em> is a subface of, if <em>face</em> is on a tree boundary. Any arbitrary integer if <em>is</em> not at a tree boundary. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The return value may look like a valid face of the tree even if the element does not lie on the root boundary. </dd></dl>

</div>
</div>
<a id="a1e049a4ab221565ed07f01ef57c8f6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e049a4ab221565ed07f01ef57c8f6cd">&#9670;&nbsp;</a></span>element_get_vertex_reference_coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_vertex_reference_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coords</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The id of the vertex whose coordinates shall be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>An array of at least as many doubles as the element's dimension whose entries will be filled with the coordinates of <em>vertex</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>coords should be zero-initialized, as only the first d coords will be set, but when used elsewhere all coords might be used. </dd></dl>

</div>
</div>
<a id="ac2dee93ff3ee83bf71d73387c24a50d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dee93ff3ee83bf71d73387c24a50d0">&#9670;&nbsp;</a></span>element_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an array of allocated elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be initialized. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elems</td><td>On input an array of <em>length</em> many allocated elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In debugging mode, an element that was passed to t8_element_init must pass <a class="el" href="t8__scheme_8h.html#aa8f96ad9d0dc56847a14df1ab817ff89">t8_element_is_valid</a>. </dd>
<dd>
If an element was created by <a class="el" href="t8__scheme_8h.html#aebd772f965b1fa5ff5ae10fe8c0950d9">t8_element_new</a> then t8_element_init may not be called for it. Thus, t8_element_init should initialize an element in the same way as a call to <a class="el" href="t8__scheme_8h.html#aebd772f965b1fa5ff5ae10fe8c0950d9">t8_element_new</a> would. </dd>
<dd>
Every call to t8_element_init must be matched by a call to t8_element_deinit </dd></dl>
<dl class="section see"><dt>See also</dt><dd>t8_element_deinit </dd>
<dd>
<a class="el" href="t8__scheme_8h.html#aebd772f965b1fa5ff5ae10fe8c0950d9" title="Allocate memory for an array of elements of a given class and initialize them.">t8_element_new</a> </dd>
<dd>
<a class="el" href="t8__scheme_8h.html#aa8f96ad9d0dc56847a14df1ab817ff89" title="Query whether a given element can be considered as &#39;valid&#39; and it is safe to perform any of the above...">t8_element_is_valid</a> </dd></dl>

</div>
</div>
<a id="a7be24712101df44758b98fe8ae3eda27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be24712101df44758b98fe8ae3eda27">&#9670;&nbsp;</a></span>element_is_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::element_is_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two elements are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the elements are equal, false if they are not equal </dd></dl>

</div>
</div>
<a id="a340289b687773932881edbad77bfed09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340289b687773932881edbad77bfed09">&#9670;&nbsp;</a></span>element_is_refinable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::element_is_refinable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if an element is refinable. </p>
<p>Possible reasons for being not refinable could be that the element has reached its max level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the element is refinable. </dd></dl>

</div>
</div>
<a id="a69ca0ed62f4cda7ca215c7aa283d1d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ca0ed62f4cda7ca215c7aa283d1d62">&#9670;&nbsp;</a></span>element_is_root_boundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::element_is_root_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether a given element shares a given face with its root tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>face</em> is a subface of the element's root element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can compute the corresponding face number of the tree via <a class="el" href="classt8__scheme.html#a38e6088c02b873127925b4469c9b9660">element_get_tree_face</a>. </dd></dl>

</div>
</div>
<a id="ac39d236fae4db6a2e6c1d234f17e1628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39d236fae4db6a2e6c1d234f17e1628">&#9670;&nbsp;</a></span>element_is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether a given element can be considered as 'valid' and it is safe to perform any of the above algorithms on it. </p>
<p>For example this could mean that all coordinates are in valid ranges and other membervariables do have meaningful values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>elem</em> is safe to use. False otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>An element that is constructed with <a class="el" href="t8__scheme_8h.html#aebd772f965b1fa5ff5ae10fe8c0950d9">t8_element_new</a> must pass this test. </dd>
<dd>
An element for which t8_element_init was called must pass this test. </dd>
<dd>
This function is used for debugging to catch certain errors. These can for example occur when an element points to a region of memory which should not be interpreted as an element. </dd>
<dd>
We recommend to use the assertion T8_ASSERT (t8_element_is_valid (elem)) in the implementation of each of the functions in this file. </dd></dl>

</div>
</div>
<a id="a42e3c7a9f56253e11e36156e3cd52a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e3c7a9f56253e11e36156e3cd52a8f">&#9670;&nbsp;</a></span>element_MPI_Pack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_MPI_Pack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **const&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>send_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack multiple elements into contiguous memory, so they can be sent via MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Array of elements that are to be packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to pack </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">send_buffer</td><td>Buffer in which to pack the elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of the buffer (in order to check that we don't access out of range) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">position</td><td>the position of the first byte that is not already packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa66cf5e55cb110aafd7249689850936e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66cf5e55cb110aafd7249689850936e">&#9670;&nbsp;</a></span>element_MPI_Pack_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_MPI_Pack_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine an upper bound for the size of the packed message of <em>count</em> elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to pack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pack_size</td><td>upper bound on the message size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6038aefd4b83edc4325c590cc5ad3e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6038aefd4b83edc4325c590cc5ad3e74">&#9670;&nbsp;</a></span>element_MPI_Unpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_MPI_Unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack multiple elements from contiguous memory that was received via MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvbuf</td><td>Buffer from which to unpack the elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of the buffer (in order to check that we don't access out of range) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">position</td><td>the position of the first byte that is not already packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Array of initialised elements that is to be filled from the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to unpack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac840fcf8915fffd21f2d75dca2382ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac840fcf8915fffd21f2d75dca2382ae5">&#9670;&nbsp;</a></span>element_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for <em>length</em> many elements of a given class and initialize them, and put pointers to the elements in the provided array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elems</td><td>On input an array of <em>length</em> many element pointers. On output all these pointers will point to an allocated and initialized element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>There are two ways to create multiple elements of the same type. Create an array of element pointers and fill it with t8_element_new, or allocate memory for <em>length</em> times <em>element_size</em> many bytes, and fill them with t8_element_init. To access a specific element, offset calculation needs to be done manually, as t8_element_t is incomplete. </dd>
<dd>
In debugging mode, an element that was created with <a class="el" href="t8__scheme_8h.html#aebd772f965b1fa5ff5ae10fe8c0950d9">t8_element_new</a> must pass <a class="el" href="t8__scheme_8h.html#aa8f96ad9d0dc56847a14df1ab817ff89">t8_element_is_valid</a> (for example the root element). </dd>
<dd>
If an element was created by <a class="el" href="t8__scheme_8h.html#aebd772f965b1fa5ff5ae10fe8c0950d9">t8_element_new</a> then t8_element_init may not be called for it. Thus, <a class="el" href="t8__scheme_8h.html#aebd772f965b1fa5ff5ae10fe8c0950d9">t8_element_new</a> should initialize an element in the same way as a call to t8_element_init would. </dd>
<dd>
Every call to <a class="el" href="t8__scheme_8h.html#aebd772f965b1fa5ff5ae10fe8c0950d9">t8_element_new</a> must be matched by a call to <a class="el" href="t8__scheme_8h.html#a416fa9e577e72a9bf21a9756eeac91c0">t8_element_destroy</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__scheme_8h.html#a416fa9e577e72a9bf21a9756eeac91c0" title="Deallocate an array of elements.">t8_element_destroy</a> </dd>
<dd>
t8_element_init </dd>
<dd>
<a class="el" href="t8__scheme_8h.html#aa8f96ad9d0dc56847a14df1ab817ff89" title="Query whether a given element can be considered as &#39;valid&#39; and it is safe to perform any of the above...">t8_element_is_valid</a> </dd></dl>

</div>
</div>
<a id="af061b230670a10f9e7f567e9349c4331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af061b230670a10f9e7f567e9349c4331">&#9670;&nbsp;</a></span>element_set_linear_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_set_linear_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the entries of an allocated element according to a given linear id in a uniform refinement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>The element whose entries will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The linear id. id must fulfil 0 &lt;= id &lt; 'number of leaves in the uniform refinement' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4c6609d8b60530303d8a8c85b56fb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c6609d8b60530303d8a8c85b56fb27">&#9670;&nbsp;</a></span>element_to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>debug_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>string_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a string with readable information about the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to translate into human-readable information </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">debug_string</td><td>The string to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa54cbd6c146c7b93ac4a8cf65efb7079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54cbd6c146c7b93ac4a8cf65efb7079">&#9670;&nbsp;</a></span>element_transform_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_transform_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>is_smaller_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suppose we have two trees that share a common face f. </p>
<p>Given an element e that is a subface of f in one of the trees and given the orientation of the tree connection, construct the face element of the respective tree neighbor that logically coincides with e but lies in the coordinate system of the neighbor tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>On return the face element <em>elem1</em> with respect to the coordinate system of the other tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation of the tree-tree connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__cmesh_8h.html#a7a3c52997f3d6eb9d02870c34171693b" title="Insert a face-connection between two trees in a cmesh.">t8_cmesh_set_join</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>Depending on the topological orientation of the two tree faces, either 0 (both faces have opposite orientation) or 1 (both faces have the same top. orientattion). <a class="el" href="t8__eclass_8h.html#a62982c7b72a0ab0b8d836beaf97bc430">t8_eclass_face_orientation</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_smaller_face</td><td>Flag to declare whether <em>elem1</em> belongs to the smaller face. A face f of tree T is smaller than f' of T' if either the eclass of T is smaller or if the classes are equal and f&lt;f'. The orientation is defined in relation to the smaller face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>elem1</em> and <em>elem2</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="a79a0afde9fa6e9dda13e2bc33e403df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a0afde9fa6e9dda13e2bc33e403df2">&#9670;&nbsp;</a></span>elements_are_family()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::elements_are_family </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const *&#160;</td>
          <td class="paramname"><em>fam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether a given set of elements is a family or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fam</td><td>An array of as many elements as an element of class <em>tree_class</em> has siblings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if <em>fam</em> is not a family, nonzero if it is. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>level 0 elements do not form a family. </dd></dl>

</div>
</div>
<a id="a41e212bb5f95d9e07e65b54c911d2c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e212bb5f95d9e07e65b54c911d2c71">&#9670;&nbsp;</a></span>get_eclass_scheme_eclass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> t8_scheme::get_eclass_scheme_eclass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the eclass an eclass scheme is valid for. </p>
<p>\Note: This function should return the input value as long as the eclass schemes are soreted correctly. In the future, the trees will access the schemes by a key and then this function will make more sense. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The valid tree class for the eclass scheme. </dd></dl>

</div>
</div>
<a id="a2b6c4d7de5838d2a7bf7f99c29467533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6c4d7de5838d2a7bf7f99c29467533">&#9670;&nbsp;</a></span>get_element_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t t8_scheme::get_element_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of any element of a given class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of an element of class <em>tree_class</em>. We provide a default implementation of this routine that should suffice for most use cases. </dd></dl>

</div>
</div>
<a id="a42ad9586fb7839910813418b6e5b22a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ad9586fb7839910813418b6e5b22a6">&#9670;&nbsp;</a></span>get_maxlevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::get_maxlevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum allowed level for any element of a given class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowed level for elements of class <em>tree_class</em>. </dd></dl>

</div>
</div>
<a id="ad1d98eada4c87673a7c189a5b2a1cb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d98eada4c87673a7c189a5b2a1cb7e">&#9670;&nbsp;</a></span>get_num_eclass_schemes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t t8_scheme::get_num_eclass_schemes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of eclass schemes inside the scheme. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of eclass schemes. </dd></dl>

</div>
</div>
<a id="a5585e34278986190d562fa76c47d6470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5585e34278986190d562fa76c47d6470">&#9670;&nbsp;</a></span>refines_irregular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::refines_irregular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if there is one element in the tree, that does not refine into 2^dim children. </p>
<p>Returns false otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is one element in the tree that does not refine into 2^dim children. </dd></dl>

</div>
</div>
<a id="ae950879e9d7dc59518d0f5908bfbd78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae950879e9d7dc59518d0f5908bfbd78e">&#9670;&nbsp;</a></span>set_to_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::set_to_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create the root element </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>The element that is filled with the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d3a78bc332b7868397b835c8317ac47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3a78bc332b7868397b835c8317ac47">&#9670;&nbsp;</a></span>unref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::unref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease the reference count of the scheme. </p>
<p>If the reference count reaches zero, the scheme is deleted. </p><dl class="section return"><dt>Returns</dt><dd>The remaining reference count. If 0 the scheme was deleted. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/t8_schemes/<a class="el" href="t8__scheme_8hxx_source.html">t8_scheme.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
